/*
 * node.h
 *
 *  Created on: May 23, 2013
 *      Author: aemen
 */

#ifndef NODE_H_
#define NODE_H_

#include "globalIncludes.h"
#include "globalStructs.h"
#include "globalVars.h"
#include "support.h"
#include "initialization.h"
#include "ixp.h"

class Node{

public:

	//experimental stuff Remove in Release version
	bool getInitialProviderRandExperimental();					//get initial provider only used in initialization*
	unsigned int numFlows;										//number of flows observed by the node
	list<int> flowsObserved;
	list<int> flowsObservedAsym;
	vector<double> estimate;
	vector<double> actual;
	vector<double> endGame;
	bool canBeProvider;

	/******* Release Version *******/
	//static members
	static vector<Node*> nodePointers;	//pointers to all nodes in the network
										//catch!!!! memory will have to be statically allocated for all nodes in this case
										//memory being statically allocated for speed
	static list<unsigned int> Tier1;
	static list<unsigned int> Tier1Save;
	static unsigned int maxNodes;		//maximum number of nodes possible in the network
	static unsigned int activeNodes;	//number of nodes currently active in the network
	static unsigned int initNodes;		//number of nodes initially active in the network
	static double universalSigma;		//universal selective peering threshold in case there is one

	//identity
	unsigned int nodeId;				//unique id of the node
	NodeCategory nodeClass;				//classification of node

	//geographic presence
	list<unsigned int> gPresence;			//ids of locations where Node has presence
	unsigned int numGPresence;				//number of regions where Node has presence
	multimap<unsigned int,NodePrice> colocatedNodePrice; //all overlapping nodes with price as well. each pair (nodeId,price) is added even though the nodeId may be same
	vector<bool> colocated;					//geographically overlapping nodes
	vector<bool> isPresentAtLoc;			//is present at a particular location

	//topology
	list<NodePrice> Q;		//providers
	list<NodePrice> I; 		//immediate customers
	list<NodePrice> J;		//customer tree
	list<NodePrice> K;		//peers
	unsigned int multihomingDegree;

	vector<bool> qProvider;
	vector<bool> iCustomer;
	vector<bool> jCustomer;
	vector<bool> kPeer;

	//economics
	vector<double> transitPriceChart;		//price maintained at each location if not present at a particular location then price is set to -1
	vector<double> paidPeeringPriceChart;	//paidPeering price at each location if not present at a particular location then price is set to -1
	double providerCost;					//total transit cost
	double freePeerCost;					//total non-paid peering cost
	double paidPeerCost;					//paid peering cost
	double paidPeerRevenue;					//paid peering revenue
	double customerRevenue;					//transit revenue
	double peeringCostExponent;				//economies of scale exponent
	double peeringCostPerMbps;				//peering cost per mbps for settlement-free peering
	double transitCostExponent;				//economies of scale exponent
	double fitness;							//fitness

	//traffic
	vector<double> trafficSent;			//traffic sent to each of the other players
	vector<double> trafficReceived;		//traffic received for consumption from each of the other players
	double totalTrafficGeneratedFraction;
	double totalTrafficGenerated;		//traffic generated by x
	double totalTrafficConsumed;		//traffic consumed by x
	double totalTrafficConsumedFraction;//fraction of total network traffic consumed by x
	double Vo;							//own traffic trafficGenerated + trafficConsumed
	double Vp;							//traffic exchanged with providers
	double Vc;							//total traffic exchanged with immediate customers
	double Vt;							//total transit traffic
	double V;							//sum of all traffic
	double Vpp;							//peering traffic
	double privatePeeringThreshold;
	double peeringThreshold;
	list<VolumePrice> customerVPList;	//traffic exchanged with customers coupled with prices
	list<VolumePrice> providerVPList;	//traffic exchanged with providers coupled with prices
	list<VolumePrice> freePeerVPList;	//traffic exchanged with peers	settlement free
	list<VolumePrice> paidPeerVPList;	//traffic exchanged with provider-peers
	list<VolumePrice> paidPeerVCList;	//traffic exchanged with customer-peers

	//peering
	double selectivePeerCriteria;							//sigma individual
	list<PeeringStrategies> availablePeeringStrategies;
	PeeringStrategies peeringStrategy;
	PeeringStrategies defaultStrategy;

	//peering trials
	std::map<string,peeringTrialsPeersStruct> peeringTrialsPeersContemporary;
	std::map<string,peeringTrialsPeersStruct> peeringTrialsPeersProposed;
	std::map<string,peeringTrialsPeersStruct> peeringTrialsPeers;
	std::map<string,peeringTrialsPeersStruct> peeringEstimatedPeersProposed;
	std::map<flowPair,peeringTrialsFlowsStruct> peeringTrialsFlows;
	std::map<flowPair,peeringTrialsFlowsStruct> peeringTrialsFlowsAsym;
	std::map<string,peeringTrialsCombinationsStruct> combinationsTrials;
	double confidenceFactorEstimation;
	double inboundTrafficWeight;
	double outboundTrafficWeight;
	double totalTrafficWeight;
	double numPeersWeight;

	Node();								//constructor

	//geographic functions
	bool isCoLocated(const unsigned int& id);				//does node id overlap geographically
	void populateColocationList();
	void assignLocation(const unsigned int&);

	//topology update functions
	void addICustomer(const NodePrice&);				//add to immediate customer list*
	bool removeICustomer(const NodePrice&);				//remove from immediate customer list*
	void addQProvider(NodePrice&);
	bool removeQProvider(const NodePrice&);
	bool addTreeToCustomerTree(const NodePrice&);		//add an entire customer tree to your own customer tree
	bool removeTreeFromCustomerTree(const NodePrice&);	//when a direct customer i 'defects' remove its customer tree from your customer tree
	bool addTreeToProviderChain(const NodePrice&);
	bool removeTreeFromProviderChain(const NodePrice&);
	void addToT1Set();
	void removeFromT1Set();

	bool removePeerFromK(const NodePrice&);
	bool insertPeerInK(const NodePrice&);

	//query functions
	bool isPresentInCustomerTree(const unsigned int &);	//is the node present in customer tree
	int isPresentInCustomerTreeOfPeer(const unsigned int &);	//is the node present in customer tree of peer
	bool isImmediateCustomer(const unsigned int &);		//is the node id an immediate customer
	bool isProvider(const unsigned int &);				//is the node id one of the providers
	bool isPresentInLocation(const unsigned int &);		//is the node present in a certain region
	bool isPeer(const unsigned int &);					//is the node id a peer
	bool isTier1();										//is the node id a tier1
	double getContractPriceForProvider(const unsigned int &);

	vector<IXPPort> peeringPorts;

	//traffic functions
	void updateVt();

	//fitness functions
	void updateFitness();
	void updateIXPPorts();							//determine the number and category of ports required for existing set of peers
	void updateIXPPorts(double);						//determine additional ports required for traffic
	double getTransitCost(double);					//for a given transit traffic volume what is the transit cost

	//provider selection functions
	bool getInitialProviderRand();							//get initial provider only used in initialization*
	bool getNewProvider();									//get new providers
	void getProviderAsZ(unsigned int,list<NodePrice>&);		//get provider for chosen provider

	//peering functions
	bool getSettlementFreePeer(const int&,bool);
	bool dePeer(const int&);
	bool checkProvidersAfterDePeering(const int&);
	peeringDecision applyPeeringCriteria(const unsigned int&);
	peeringDecision evaluateExistingPeer(const unsigned int&);
	peeringDecision (Node::*strategyPointer)(const unsigned int&);
	peeringDecision (Node::*dStrategyPointer)(const unsigned int&);
	void selectPeeringStrategy(PeeringStrategies);
	peeringDecision peeringStrategySelective(const unsigned int&);
	peeringDecision dePeeringStrategySelective(const unsigned int&);
	peeringDecision peeringStrategyOpen(const unsigned int&);
	peeringDecision dePeeringStrategyOpen(const unsigned int&);
	peeringDecision peeringStrategyRestrictive(const unsigned int&);
	peeringDecision dePeeringStrategyRestrictive(const unsigned int&);
	peeringDecision peeringStrategySelectiveReal(const unsigned int&);
	peeringDecision dePeeringStrategySelectiveReal(const unsigned int&);
	bool updatePeeringStrategyFitnessPrediction();

	//peering trials
	void peerOperatorNoTrial(bool);
	void peerOperatorTrial(bool);
	peeringDecision tryAndVerify(const unsigned int&);
	void peerNetFlowEstimation(bool,estimatorStrength);
	void peerNetFlowEstimationPacking(bool,estimatorStrength);
	double estimateTrafficUpperBound(const unsigned int &);
	double estimateTrafficLowerBound(const unsigned int &);
	double estimateTrafficExchangeSlack(const unsigned int &);
	double estimateTrafficExchangeSlack(const unsigned int &, vector<int>&, vector<int>&);
	double estimateTrafficExchangeTight(const unsigned int &);
	double estimateTrafficFromSlack(const unsigned int &);
	double estimateTrafficToSlack(const unsigned int &);
	double estimateTrafficFromSlack(const unsigned int &, vector<int>&, vector<int>&);
	double estimateTrafficToSlack(const unsigned int &, vector<int>&, vector<int>&);
	double estimateTrafficFromTight(const unsigned int &);
	double estimateTrafficToTight(const unsigned int &);
	double estimateTrafficToTight(const unsigned int&, vector<int>&, vector<int>&);
	NodePrice estimateUtility(const unsigned int &, estimatorStrength);

	//functions for peering advisor
	void dopeeringTrialsProposed(bool);
	bool isPotentialCustomer(unsigned int);
	void peeringTrialsProposedStubs(set<unsigned int>&);
	void peeringTrialsProposedProviders(set<unsigned int>&);
	bool isTrialCandidate(unsigned int&);
	void findTrialCandidates(const set<unsigned int>&,list<nodeTrafficRank>&);
	void trialWithIndividualProviders(const list<nodeTrafficRank>&);
	void peeringTrialsProposedCombinations(const list<nodeTrafficRank>&);

	//functions for peer selection experiments
	void peerSelectionGreedyPack();
	void peerSelectionFFDLR();
	void peerSelectionPaidPeering();
	void peerSelectionEstimation(estimatorStrength,bool);
	double computePeeringCostForTraffic(double);

	//friends of nodes
	friend void establishLinkWithProvider(const unsigned int&, const unsigned int&);
	friend void establishFlowWithProvider(const unsigned int&,const unsigned int&);

	friend void endLink(const unsigned int&, const unsigned int&);
	friend void endFlow(const unsigned int&, const unsigned int&);

	friend void establishLinkWithPeer(const unsigned int&, const unsigned int&, bool);
	friend void establishFlowWithPeer(const unsigned int&,const unsigned int&);

	friend void endConditionalFlowsBetweenSets(const list<unsigned int>&, const list<unsigned int>&);

	friend void establishFlowsBetweenNodeAndSet(const unsigned int &, const list<unsigned int> &);
	friend void establishFlowsBetweenSets(const list<unsigned int> &, const list<unsigned int> &);

	friend bool establishFlowBetweenNonLinkedNodes(const unsigned int &,const unsigned int &);
	friend bool establishFlowBetweenNonLinkedNodesAsym(const unsigned int &, const unsigned int &);

	//friend void routeTraffic();

	friend void saveNetworkState();
	friend void restoreNetworkState();

};

extern void computeTrafficFlowsAcrossNetwork();
extern void computeTrafficFlowsAcrossNode(const unsigned int&);

//friends of nodes
extern void establishLinkWithProvider(const unsigned int&, const unsigned int&);
extern void establishFlowWithProvider(const unsigned int&,const unsigned int&);

extern void endLink(const unsigned int&, const unsigned int&);
extern void endFlow(const unsigned int&, const unsigned int&);

extern void establishLinkWithPeer(const unsigned int&, const unsigned int&, bool);
extern void establishFlowWithPeer(const unsigned int&,const unsigned int&);

extern void endConditionalFlowsBetweenSets(const list<unsigned int>&, const list<unsigned int>&);

extern void establishFlowsBetweenNodeAndSet(const unsigned int &, const list<unsigned int> &);
extern void establishFlowsBetweenSets(const list<unsigned int> &, const list<unsigned int> &);

extern bool establishFlowBetweenNonLinkedNodes(const unsigned int &,const unsigned int &);
extern bool establishFlowBetweenNonLinkedNodesAsym(const unsigned int &, const unsigned int &);

extern void saveNetworkState();
extern void restoreNetworkState();

extern list<int> freeFlowIndices;

extern Node* aliveNodes;
extern Node* aliveNodesSave;

extern linkInfo** linkIndex;
extern linkInfo** linkIndexSave;

extern map<int,connectedNodes> linkMap;
extern map<int,connectedNodes> flowSymMap;
extern map<int,connectedNodes> flowAsymMap;

extern int** flowIndex;
extern int** flowIndexSave;

extern bool* aliveLinkIndicator;
extern bool* aliveLinkIndicatorSave;

extern bool* aliveFlowIndicator;
extern bool* aliveFlowIndicatorSave;

extern list<flowInfo>* routingMatrix;
extern list<flowInfo>* routingMatrixAsym;
extern list<flowInfo>* routingMatrixSave;
extern list<flowInfo>* routingMatrixAsymSave;

extern unsigned int* flowDirectionFrom;
extern unsigned int* flowDirectionFromAsym;
extern unsigned int* flowDirectionFromSave;
extern unsigned int* flowDirectionFromAsymSave;

extern double* flowValueVector;
extern double* flowValueVectorAsym;
extern double* flowValueVectorSave;
extern double* flowValueVectorAsymSave;

extern double* linkValueVector;
extern double* linkValueVectorSave;
extern double* linkValueVectorUpstream;
extern double* linkValueVectorUpstreamSave;
extern double* linkValueVectorDownstream;
extern double* linkValueVectorDownstreamSave;
extern double* linkValueVectorFlat;
extern double* linkValueVectorFlatSave;
extern double* linkValueVectorFlatLeft;
extern double* linkValueVectorFlatLeftSave;
extern double* linkValueVectorFlatRight;
extern double* linkValueVectorFlatRightSave;

extern unsigned int maxFlows;
extern unsigned int maxLinks;


//TODO remove experimental version
extern unsigned int* numFlowsOverLink;

#endif /* NODE_H_ */
