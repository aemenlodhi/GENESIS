/*
 * node.cpp
 *
 *  Created on: Feb 27, 2013
 *      Author: aemen
 */

#include "node.h"
#include "geography.h"
#include "support.h"

vector<Node*> Node::nodePointers;
list<unsigned int>Node::Tier1;
list<unsigned int>Node::Tier1Save;
unsigned int Node::maxNodes=0;
unsigned int Node::activeNodes=0;
unsigned int Node::initNodes=0;
double Node::universalSigma=0;
Node* aliveNodes;
Node* aliveNodesSave;

//Experimental stuff
//TODO Remove Experimental stuff from release version
bool Node::getInitialProviderRandExperimental(){

		//list<NodePrice>::iterator it;
		bool providerChosen=false;
		map<unsigned int,double> providerMap;
		map<unsigned int,double>::iterator itMap;
		NodePrice pProvider;
		vector<NodePrice> possibleProvider;

		//create a list of possible providers
		for(std::multimap<unsigned int,NodePrice>::iterator it=colocatedNodePrice.begin();it!=colocatedNodePrice.end();it++){
			if(!isPresentInCustomerTree((*it).second.nId) && nodePointers[(*it).second.nId]->numGPresence>=numGPresence && nodePointers[(*it).second.nId]->numGPresence>1 && nodePointers[(*it).second.nId]->canBeProvider==true){

				//choose lowest overlapping price
				if(providerMap.find((*it).second.nId)!=providerMap.end()){
					if(providerMap[(*it).second.nId]>(*it).second.price){
						providerMap[(*it).second.nId]=(*it).second.price;
					}
				}

				else{
					providerMap[(*it).second.nId]=(*it).second.price;
				}

			}

		}

		for(itMap=providerMap.begin();itMap!=providerMap.end();itMap++){
				pProvider.nId=itMap->first;
				pProvider.price=itMap->second;
				possibleProvider.push_back(pProvider);
		}


		//choose providers
		if(!possibleProvider.empty()){

			std::random_shuffle(possibleProvider.begin(),possibleProvider.end());

			do{	//loop till multihoming degree is done

				pProvider=possibleProvider.front();
				possibleProvider.erase(possibleProvider.begin());

				NodePrice customerInfo;
				customerInfo.nId=nodeId;
				customerInfo.price=pProvider.price;

				addQProvider(pProvider);
				nodePointers[pProvider.nId]->addICustomer(customerInfo);
				nodePointers[pProvider.nId]->addTreeToCustomerTree(customerInfo);
				nodePointers[pProvider.nId]->addTreeToProviderChain(customerInfo);

				providerChosen=true;

				establishLinkWithProvider(nodeId,pProvider.nId);
				establishFlowWithProvider(nodeId,pProvider.nId);

			}while(Q.size()<multihomingDegree && !possibleProvider.empty());

		}//end if

		return providerChosen;

}



Node::Node(){

	//experimental stuff
	canBeProvider=false;
	numFlows=0;


	//identity
	nodeId=-1;
	nodeClass=Stub;

	//topology
	multihomingDegree=1;

	//geographic presence
	numGPresence=1;				//number of regions where Node has presence

	//economics
	 providerCost=0;			//total transit cost
	 freePeerCost=0;			//total peering cost
	 paidPeerCost=0;			//paid peering cost
	 paidPeerRevenue=0;			//paid peering revenue
	 customerRevenue=0;			//transit revenue
	 peeringCostExponent=0; 	//economies of scale exponent
	 peeringCostPerMbps=0;		//peering cost per mbps
	 transitCostExponent=TRANSIT_COST_EXPONENT;		//economies of scale exponent
	 fitness=0;					//fitness

	//traffic
	 totalTrafficGenerated=0;		//traffic generated by x
	 totalTrafficConsumed=0;		//traffic consumed by x
	 totalTrafficConsumedFraction=0;//fraction of total traffic consumed by x
	 Vo=0;							//own traffic trafficGenerated + trafficConsumed
	 Vp=0;							//traffic exchanged with providers
	 Vc=0;							//total traffic exchanged with customers
	 Vt=0;							//transit traffic
	 V=0;							//sum of all traffic
	 Vpp=0;							//peering traffic
	 privatePeeringThreshold=0;
	 peeringThreshold=0;

	//peering
	selectivePeerCriteria=1;							//sigma
	peeringStrategy=Restrictive;
	defaultStrategy=Restrictive;
	availablePeeringStrategies.push_back(Selective);
	availablePeeringStrategies.push_back(Open);
	availablePeeringStrategies.push_back(Restrictive);

	//((Node*)this)->Node::strategyPointer(nullptr);
	//((Node*)this)->Node::dStrategyPointer(nullptr);

	colocated.assign(maxNodes,false);
	qProvider.assign(maxNodes,false);
	iCustomer.assign(maxNodes,false);
	jCustomer.assign(maxNodes,false);
	kPeer.assign(maxNodes,false);
	trafficSent.assign(maxNodes,0.0);
	trafficReceived.assign(maxNodes,0.0);
	transitPriceChart.assign(Location::maxLocations,-1);
	paidPeeringPriceChart.assign(Location::maxLocations,-1);


}

inline bool Node::isCoLocated(const unsigned int& id)
{
	return colocated[id];
}

void Node::populateColocationList(){

	NodePrice tempNP;
	for(list<unsigned int>::iterator it=gPresence.begin();it!=gPresence.end();it++){
		for(list<unsigned int>::iterator gt=world[*it].nodePresent.begin();gt!=world[*it].nodePresent.end();gt++){
			if(*gt!=nodeId){
				tempNP.nId=*gt;
				tempNP.price=nodePointers[*gt]->transitPriceChart[*it];
				colocatedNodePrice.insert(std::pair<unsigned int,NodePrice>(*it,tempNP));
				colocated[tempNP.nId]=true;
			}

		}

	}

}

inline void Node::assignLocation(const unsigned int& loc){

	isPresentAtLoc[loc]=true;
	gPresence.push_back(loc);
	numGPresence++;
}

inline void Node::addICustomer(const NodePrice& id){

	I.push_back(id);
	iCustomer[id.nId]=true;

}

bool Node::removeICustomer(const NodePrice& i){

	//TODO: insert exception handling
	if(std::find(I.begin(),I.end(),i)==I.end())
		return false;

	I.remove(i);
	iCustomer[i.nId]=false;
	return true;

}

inline void Node::addQProvider(NodePrice& id){
	Q.push_back(id);
	qProvider[id.nId]=true;
}

bool Node::removeQProvider(const NodePrice& q){

	//TODO: add exception  handling
	if(std::find(Q.begin(),Q.end(),q)==Q.end())
		return false;

	Q.remove(q);
	qProvider[q.nId]=false;
	return true;
}

bool Node::addTreeToCustomerTree(const NodePrice& j){

	if(!jCustomer[j.nId]){
		J.push_back(j);
		jCustomer[j.nId]=true;
	}

	for(list<NodePrice>::iterator it=nodePointers[j.nId]->J.begin();it!=nodePointers[j.nId]->J.end();it++)
		if(!jCustomer[(*it).nId]){
			J.push_back(*it);
			jCustomer[(*it).nId]=true;
		}

	return true;

}

bool Node::removeTreeFromCustomerTree(const NodePrice& j){

	bool flag=false;

	if(isImmediateCustomer(j.nId))
		flag=true;

	if(flag==false){
		//check if j itself is present in the customer tree of another immediate customer or is immediate customer itself
		for(list<NodePrice>::iterator it=I.begin();it!=I.end();it++){
			if(nodePointers[(*it).nId]->isPresentInCustomerTree(j.nId)){
				flag=true;
				break;
			}
		}
	}

	if(flag==false){
		J.remove(j);
		jCustomer[j.nId]=false;

		//check if j's customer tree members are present in customer trees of other immediate customers
		for(list<NodePrice>::iterator jt=nodePointers[j.nId]->J.begin();jt!=nodePointers[j.nId]->J.end();jt++){

			flag=false;

			if(isImmediateCustomer((*jt).nId))
				flag=true;

			if(flag==false){
				for(list<NodePrice>::iterator it=I.begin();it!=I.end();it++){
					if(nodePointers[(*it).nId]->isPresentInCustomerTree((*jt).nId)){
						flag=true;
						break;
					}
				}
			}

			if(flag==false){
				J.remove(*jt);
				jCustomer[(*jt).nId]=false;
			}
		}

	}

	return true;
}

bool Node::addTreeToProviderChain(const NodePrice& j){

	if(Q.empty())
		return true;

	list<NodePrice>::iterator itNP;
	list<NodePrice> providerChain=Q;

	for(itNP=providerChain.begin();itNP!=providerChain.end();itNP++){

		if(!nodePointers[(*itNP).nId]->Q.empty())
			copySecondListIntoFirst<NodePrice>(providerChain,nodePointers[(*itNP).nId]->Q);

	}

	providerChain.sort(sortById);
	providerChain.unique(removeSameId);

	for(itNP=providerChain.begin();itNP!=providerChain.end();itNP++)
		nodePointers[(*itNP).nId]->addTreeToCustomerTree(j);


	return true;
}

bool Node::removeTreeFromProviderChain(const NodePrice& j){

	if(Q.empty())
		return true;

	list<NodePrice>::iterator itNP;
	list<NodePrice> providerChain=Q;
	list<unsigned int> analysisDone;

	for(itNP=providerChain.begin();itNP!=providerChain.end();itNP++){

		if(!nodePointers[(*itNP).nId]->Q.empty())
			copySecondListIntoFirst<NodePrice>(providerChain,nodePointers[(*itNP).nId]->Q);

	}

	for(itNP=providerChain.begin();itNP!=providerChain.end();itNP++){

		if(!isPresentInList(analysisDone,(*itNP).nId)){
			nodePointers[(*itNP).nId]->removeTreeFromCustomerTree(j);
			analysisDone.push_back((*itNP).nId);
		}

	}


	/*
	if(Q.size()>1){
		providerChain.push_back(Q.front());
		for(list<NodePrice>::iterator it=Q.begin();it!=Q.end();it++){
			if(it!=Q.begin()){
				inserted=false;
				for(list<NodePrice>::iterator jt=providerChain.begin();jt!=providerChain.end();jt++){
					if(nodePointers[(*jt).nId]->isPresentInCustomerTree((*it).nId)){
						providerChain.insert(jt,*it);
						inserted=true;
						break;
					}

				}

				if(!inserted)
					providerChain.push_back(*it);
			}
		}

	}

	else
		providerChain.push_back(Q.front());

	for(itNP=providerChain.begin();itNP!=providerChain.end();itNP++){

		if(!nodePointers[(*itNP).nId]->Q.empty())
			copySecondListIntoFirst<NodePrice>(providerChain,nodePointers[(*itNP).nId]->Q);

	}

	for(itNP=providerChain.begin();itNP!=providerChain.end();itNP++)
		nodePointers[(*itNP).nId]->removeTreeFromCustomerTree(j);
	*/

	return true;

}


bool Node::removePeerFromK(const NodePrice& k){

	if(kPeer[k.nId]){
		K.remove(k);
		kPeer[k.nId]=false;
		return true;
	}

	else
		return false;

}

bool Node::insertPeerInK(const NodePrice& k){

	list<NodePrice>::iterator itK;
	bool inserted=false;

	if(isPeer(k.nId)){

		cout<<"Node "<<nodeId<<" peering with existing peer "<<k.nId<<endl;
		string str("ERROR!! Peering with an existing peer.");
		endSimulation(str);
		return false;
	}


	else{

		if(K.empty()){

			K.push_back(k);
			kPeer[k.nId]=true;
			inserted=true;
		}

		else{

			for(itK=K.begin();itK!=K.end();itK++){

				if(nodePointers[(*itK).nId]->isPresentInCustomerTree(k.nId)){
					K.insert(itK,k);
					kPeer[k.nId]=true;
					inserted=true;
					break;
				}
			}
		}

		if(!inserted){
			K.push_back(k);
			kPeer[k.nId]=true;
		}

		return true;
	}

}

inline bool Node::isPresentInCustomerTree(const unsigned int& id){

	return jCustomer[id];

}

int Node::isPresentInCustomerTreeOfPeer(const unsigned int& id){

	list<NodePrice>::iterator it;

	if(K.empty())
		return -1;

	else{

		for(it=K.begin();it!=K.end();it++){

			if(nodePointers[(*it).nId]->isPresentInCustomerTree(id))
				return static_cast<int>((*it).nId);

		}//end for

	}//end else

	return -1;

}

inline bool Node::isImmediateCustomer(const unsigned int& id){

	return iCustomer[id];
}

inline bool Node::isProvider(const unsigned int& id){

	return qProvider[id];

}

inline bool Node::isPresentInLocation(const unsigned int& loc){

	return isPresentAtLoc[loc];

}

inline bool Node::isPeer(const unsigned int& id){

	return kPeer[id];

}

inline bool Node::isTier1(){

	if(Q.empty() && isPresentInList(Tier1,nodeId))
		return true;
	else
		return false;
}

double Node::getContractPriceForProvider(const unsigned int& id){

	list<NodePrice>::iterator it;

	for(it=Q.begin();it!=Q.end();it++){
		if((*it).nId==id)
			return (*it).price;
	}

	string str="ERROR!!! Could not find provider in list to get contract price";
	endSimulation(str);
	return -1;
}

void Node::updateVt(){

	Vt=0.5*(Vpp + Vp + Vc - Vo);

	V=totalTrafficConsumed+totalTrafficGenerated+Vt;

	if(Vt<0){

		/*
				displayNodeData();
				displayTrafficMatrix();
				displayTopology();
				displayRouteData();
		 */
		char msg[100];
		sprintf(msg,"ERROR!!! Vt fallen below zero for node %d",nodeId);
		string str(msg);
		endSimulation(str);

	}

	if(V<(totalTrafficGenerated+totalTrafficConsumed)){

		/*
				displayNodeData();
				displayTrafficMatrix();
				displayTopology();
				displayRouteData();
		 */
		char msg[100];
		sprintf(msg,"ERROR!!! V turned out to be less than local traffic for node %d",nodeId);
		string str(msg);
		endSimulation(str);

	}

}

double Node::getTransitCost(double traffic){

	double tcost    = 0;

	if ( traffic < 1000 ) {
		tcost = traffic * TRANSIT_PRICE_100MBPS;
	}

	else if ( traffic >= 1000 && traffic < 10000 ) {
		tcost = traffic * TRANSIT_PRICE_1GBPS;
	}

	else if ( traffic >= 10000 && traffic < 100000 ) {
		tcost = traffic * TRANSIT_PRICE_10GBPS;
	}

	else {
		tcost = traffic * TRANSIT_PRICE_100GBPS;
	}

	return tcost;


}

void Node::updateFitness(){

	list<VolumePrice>::iterator itVP;

	double publicPeerVolume=0;

	fitness=paidPeerCost=paidPeerRevenue=freePeerCost=providerCost=customerRevenue=0;

	//calculating free peer cost
	if(!K.empty() || !freePeerVPList.empty()){

		if(IXP_PEERING==false){
			for(itVP=freePeerVPList.begin();itVP!=freePeerVPList.end();itVP++){

				if(PRIVATE_PEERING==true && (*itVP).volume>=privatePeeringThreshold)
					freePeerCost+=pow((*itVP).volume,peeringCostExponent);
				else
					publicPeerVolume+=(*itVP).volume;
			}

			freePeerCost+=pow(publicPeerVolume,peeringCostExponent);

			freePeerCost=freePeerCost*peeringCostPerMbps;
		}

		else{

			//updateIXPPorts();

			for(vector<IXPPort>::iterator it=peeringPorts.begin();it!=peeringPorts.end();it++){

				freePeerCost+=(*it).getPortCosts();

			}

		}

	}

	//calculating paid peer cost
	if(!K.empty() && !paidPeerVPList.empty()){

		if(IXP_PEERING==false){
			for(itVP=paidPeerVPList.begin();itVP!=paidPeerVPList.end();itVP++){
				paidPeerCost+=((*itVP).contractPrice*pow((*itVP).volume,peeringCostExponent));
			}
		}

		else{
			for(itVP=paidPeerVPList.begin();itVP!=paidPeerVPList.end();itVP++){
				if((*itVP).volume<100){
					paidPeerCost+=(3*(*itVP).volume);
				}

				else if((*itVP).volume>=100 && (*itVP).volume<1000){
					paidPeerCost+=(2*(*itVP).volume);
				}

				else
					paidPeerCost+=(0.5*(*itVP).volume);
			}

		}

	}

	//calculating provider cost
	if(!Q.empty() && !providerVPList.empty()){

		if(IXP_PEERING==false){
#if DEBUG
		cout<<"Provider costs\t";
#endif
		for(itVP=providerVPList.begin();itVP!=providerVPList.end();itVP++){
			providerCost+=((*itVP).contractPrice*pow((*itVP).volume,transitCostExponent));
#if DEBUG
			cout<<providerCost<<":\t"<<(*itVP).contractPrice<<"*"<<(*itVP).volume<<endl;
#endif
		}

#if DEBUG
		//cout<<endl;
#endif
		}

		else{

			for(itVP=providerVPList.begin();itVP!=providerVPList.end();itVP++){

				providerCost+=getTransitCost((*itVP).volume);

			}

		}

	}

	//calculating customer revenue
	if(!I.empty() && !customerVPList.empty()){

		if(IXP_PEERING==false){
			for(itVP=customerVPList.begin();itVP!=customerVPList.end();itVP++)
				customerRevenue+=((*itVP).contractPrice*pow((*itVP).volume,transitCostExponent));
		}

		else{
			for(itVP=customerVPList.begin();itVP!=customerVPList.end();itVP++){
				customerRevenue+=getTransitCost((*itVP).volume);
			}
		}
	}

	//calculating paid peer revenue
	if(!K.empty() && !paidPeerVCList.empty()){

		for(itVP=paidPeerVCList.begin();itVP!=paidPeerVCList.end();itVP++){
			paidPeerRevenue+=((*itVP).contractPrice*pow((*itVP).volume,peeringCostExponent));
		}

	}

	//calculating fitness
	fitness=customerRevenue+paidPeerRevenue-providerCost-paidPeerCost-freePeerCost;

}

bool Node::getInitialProviderRand(){

		//list<NodePrice>::iterator it;
		bool providerChosen=false;
		map<unsigned int,double> providerMap;
		map<unsigned int,double>::iterator itMap;
		NodePrice pProvider;
		vector<NodePrice> possibleProvider;

		//create a list of possible providers
		for(std::multimap<unsigned int,NodePrice>::iterator it=colocatedNodePrice.begin();it!=colocatedNodePrice.end();it++){
			if(!isPresentInCustomerTree((*it).second.nId) && nodePointers[(*it).second.nId]->numGPresence>=numGPresence && nodePointers[(*it).second.nId]->numGPresence>1 && nodePointers[(*it).second.nId]->canBeProvider==true){

				//choose lowest overlapping price
				if(providerMap.find((*it).second.nId)!=providerMap.end()){
					if(providerMap[(*it).second.nId]>(*it).second.price){
						providerMap[(*it).second.nId]=(*it).second.price;
					}
				}

				else{
					providerMap[(*it).second.nId]=(*it).second.price;
				}

			}

		}

		for(itMap=providerMap.begin();itMap!=providerMap.end();itMap++){
				pProvider.nId=itMap->first;
				pProvider.price=itMap->second;
				possibleProvider.push_back(pProvider);
		}


		//choose providers
		if(!possibleProvider.empty()){

			std::random_shuffle(possibleProvider.begin(),possibleProvider.end());

			do{	//loop till multihoming degree is done

				pProvider=possibleProvider.front();
				possibleProvider.erase(possibleProvider.begin());

				NodePrice customerInfo;
				customerInfo.nId=nodeId;
				customerInfo.price=pProvider.price;

				addQProvider(pProvider);
				nodePointers[pProvider.nId]->addICustomer(customerInfo);
				nodePointers[pProvider.nId]->addTreeToCustomerTree(customerInfo);
				nodePointers[pProvider.nId]->addTreeToProviderChain(customerInfo);

				providerChosen=true;

				establishLinkWithProvider(nodeId,pProvider.nId);
				establishFlowWithProvider(nodeId,pProvider.nId);

			}while(Q.size()<multihomingDegree && !possibleProvider.empty());

		}//end if

		return providerChosen;

}

bool Node::getNewProvider(){

	list<NodePrice> QPrev=Q;		//list of existing providers
	NodePrice customerInfo;

	NodePrice z;
	list<NodePrice> possibleProvider;
	bool providerChange=false;
	NodePrice pProvider;
	map<unsigned int,double> providerMap;
	map<unsigned int,double>::iterator itMap;

#if 0
	logFile<<"I"<<iterations<<":"<<"N"<<nodeId<<": GetNewProvider"<<endl;
	logFile<<"\t\tPossible providers: ";
#endif


	//create a list of possible providers
	//TODO update the case when prices are dynamic. In that case identify the provider by id only and not (id,price) pair
	for(std::multimap<unsigned int,NodePrice>::iterator it=colocatedNodePrice.begin();it!=colocatedNodePrice.end();it++){
		if(!isPeer((*it).second.nId) && -1==isPresentInCustomerTreeOfPeer((*it).second.nId) && nodePointers[(*it).second.nId]->numGPresence>=numGPresence && nodePointers[(*it).second.nId]->Vt>Vt && nodePointers[(*it).second.nId]->numGPresence>1){

			pProvider.nId=(*it).second.nId;

			if(providerMap.find((*it).second.nId)!=providerMap.end()){
				if(providerMap[(*it).second.nId]>(*it).second.price){
					providerMap[(*it).second.nId]=(*it).second.price;
				}
			}

			else{
				providerMap[(*it).second.nId]=(*it).second.price;
			}

			pProvider.price=providerMap[(*it).second.nId];

			possibleProvider.push_back(pProvider);
		}
	}

	//no provider change
	if(QPrev.empty() && possibleProvider.empty())
		return false;

	QPrev.sort(sortByPrice);
	possibleProvider.sort(sortByPrice);

	if(possibleProvider.size()>multihomingDegree){
		possibleProvider.resize(multihomingDegree);	//truncate to only the cheapest possible providers
	}

	//cheapest providers are the same
	if(compareProviders(QPrev,possibleProvider))
		return false;

	if(!QPrev.empty())
		for(std::list<NodePrice>::iterator it=QPrev.begin();it!=QPrev.end();it++)
			if(!isPresentInList<NodePrice>(possibleProvider,*it)){

				customerInfo.nId=nodeId;
				customerInfo.price=getContractPriceForProvider((*it).nId);

				removeQProvider(*it);
				nodePointers[(*it).nId]->removeICustomer(customerInfo);
				nodePointers[(*it).nId]->removeTreeFromCustomerTree(customerInfo);
				nodePointers[(*it).nId]->removeTreeFromProviderChain(customerInfo);

				endLink(nodeId,(*it).nId);
				endFlow(nodeId,(*it).nId);

			}

	if(!possibleProvider.empty()){
		list<NodePrice> tempList=possibleProvider;

		for(std::list<NodePrice>::iterator it=tempList.begin();it!=tempList.end();it++){
			if(isPresentInList<NodePrice>(possibleProvider,*it))
				possibleProvider.remove(*it);
		}

	}

	list<unsigned int> customers;
	list<unsigned int> outsiders;

	if(possibleProvider.empty()){	//x becomes tier-1

			//terminate flows that need to be terminated
			//add x to tier-1 set
			//re-establish flows

			//form set of outsiders
			//outsiders do not include peers, customers, customer-tree nodes, nodes which are present in customer-tree of peers
			for(unsigned int i=0;i<activeNodes;i++){
				if(!isPresentInCustomerTree(i) && !isPeer(i) && !isPresentInCustomerTreeOfPeer(i))
					outsiders.push_back(i);
				else
					customers.push_back(i);
			}
			customers.push_front(nodeId); //terminate flows between x and outsiders if required

			//add x to tier-1 set
			//establishing links and flows with Tier-1 nodes
			addToT1Set();

			//terminate flows among customers if they are not peers, customer-providers, present in customer trees of each other's peers
			endConditionalFlowsBetweenSets(customers,customers);

			//terminate flows between customers and outsiders
			endConditionalFlowsBetweenSets(customers,outsiders);

			//re-establish flows
			//establish flows between x and the outside world
			establishFlowsBetweenNodeAndSet(nodeId,outsiders);

			//establish flows between customers
			establishFlowsBetweenSets(customers,customers);

			//establish flows between customers and the outside world
			establishFlowsBetweenSets(customers,outsiders);

			return true;


	}//end if possibleProvider.empty()

	else{	//possibleProvider not empty

		do{

			customers.clear();
			outsiders.clear();

			z=possibleProvider.front();
			possibleProvider.pop_front();

			if(QPrev.empty()){	//x was Tier 1

				if(nodePointers[z.nId]->Q.empty()){ //if z is currently Tier1

					string str="ERROR!!! Tier1 choosing another Tier1 as provider without depeering\nERROR!! Provider selection flawed";
					endSimulation(str);
					return false;

				}//end if z is tier 1

				else{	//z is not tier1

					list<NodePrice> zNewProvider;
					nodePointers[z.nId]->getProviderAsZ(nodeId,zNewProvider);	//check if z is capable of becoming T1

					if(zNewProvider.empty()){	//z is capable of becoming Tier1 -> degrade X

						//remove x from Tier1
						removeFromT1Set();

						//end relationship of z with its previous providers
						list<NodePrice> tempList=nodePointers[z.nId]->Q;
						for(std::list<NodePrice>::iterator it=tempList.begin();it!=tempList.end();it++){
							nodePointers[(*it).nId]->removeICustomer(z);
							nodePointers[(*it).nId]->removeTreeFromCustomerTree(z);
							nodePointers[(*it).nId]->removeTreeFromProviderChain(z);
							nodePointers[z.nId]->removeQProvider(*it);
							endLink(z.nId,(*it).nId);
							endFlow(z.nId,(*it).nId);
						}
						tempList.clear();

						//make z a tier-1
						nodePointers[z.nId]->addToT1Set();

						//**put x in the customer tree of z
						NodePrice tempNP;
						tempNP.nId=nodeId;
						tempNP.price=z.price;

						//end previous flow of x with z
						endFlow(nodeId,z.nId);

						//update topology
						addQProvider(z);
						nodePointers[z.nId]->addICustomer(tempNP);
						nodePointers[z.nId]->addTreeToCustomerTree(tempNP);
						nodePointers[z.nId]->addTreeToProviderChain(tempNP);

						//update routing information
						establishLinkWithProvider(nodeId,z.nId);
						establishFlowWithProvider(nodeId,z.nId);

						//populate customers set (customers of z)
						list<NodePrice>::iterator it1;
						for(unsigned int i=0;i<activeNodes;i++){
							if(nodePointers[z.nId]->isPresentInCustomerTree(i))
								customers.push_back(i);
							else
								outsiders.push_back(i);
						}
						customers.push_front(z.nId);

						//terminate flows among customers if they are not peers, customer-providers, present in customer trees of each other's peers
						endConditionalFlowsBetweenSets(customers,customers);

						//terminate flows between customers and outsiders
						endConditionalFlowsBetweenSets(customers,outsiders);

						//re-establish flows
						//establish flows between x and the outside world
						establishFlowsBetweenNodeAndSet(z.nId,outsiders);

						//establish flows between customers
						establishFlowsBetweenSets(customers,customers);

						//establish flows between customers and the outside world
						establishFlowsBetweenSets(customers,outsiders);

						providerChange=true;
					}//if z is capable of becoming Tier1

				}//end else Z is not tier1

			}//end if x is Tier 1


			else{	//x is not Tier1

				if(isPresentInCustomerTree(z.nId)){	//z is present in customer tree of x

					list<NodePrice> zNewProvider;
					nodePointers[z.nId]->getProviderAsZ(nodeId,zNewProvider);

					if(zNewProvider.empty()){	//z becomes Tier1

						//end relationship of z with its previous providers
						list<NodePrice> tempList=nodePointers[z.nId]->Q;
						for(std::list<NodePrice>::iterator it=tempList.begin();it!=tempList.end();it++){
							nodePointers[(*it).nId]->removeICustomer(z);
							nodePointers[(*it).nId]->removeTreeFromCustomerTree(z);
							nodePointers[(*it).nId]->removeTreeFromProviderChain(z);
							nodePointers[z.nId]->removeQProvider(*it);
							endLink(z.nId,(*it).nId);
							endFlow(z.nId,(*it).nId);
						}
						tempList.clear();

						//make z a tier-1
						nodePointers[z.nId]->addToT1Set();

						//**put x in the customer tree of z
						NodePrice tempNP;
						tempNP.nId=nodeId;
						tempNP.price=z.price;

						//end previous flow of x with z
						endFlow(nodeId,z.nId);

						//update topology
						addQProvider(z);
						nodePointers[z.nId]->addICustomer(tempNP);
						nodePointers[z.nId]->addTreeToCustomerTree(tempNP);
						nodePointers[z.nId]->addTreeToProviderChain(tempNP);

						//update routing information
						establishLinkWithProvider(nodeId,z.nId);
						establishFlowWithProvider(nodeId,z.nId);

						//populate customers set (customers of z)
						list<NodePrice>::iterator it1;
						for(unsigned int i=0;i<activeNodes;i++){
							if(nodePointers[z.nId]->isPresentInCustomerTree(i))
								customers.push_back(i);
							else
								outsiders.push_back(i);
						}
						customers.push_front(z.nId);

						//terminate flows among customers if they are not peers, customer-providers, present in customer trees of each other's peers
						endConditionalFlowsBetweenSets(customers,customers);

						//terminate flows between customers and outsiders
						endConditionalFlowsBetweenSets(customers,outsiders);

						//re-establish flows
						//establish flows between x and the outside world
						establishFlowsBetweenNodeAndSet(z.nId,outsiders);

						//establish flows between customers
						establishFlowsBetweenSets(customers,customers);

						//establish flows between customers and the outside world
						establishFlowsBetweenSets(customers,outsiders);

						providerChange=true;

					}//end if Z becomes Tier 1

					else{	//z does not become Tier1

						//update the providers of z and its provider chain
						//add x to the customer tree of z
						//update provider chains

						//**put x in the customer tree of z
						NodePrice tempNP;
						tempNP.nId=nodeId;
						tempNP.price=z.price;

						//end previous flow of x with z
						endFlow(nodeId,z.nId);

						//update topology
						addQProvider(z);
						nodePointers[z.nId]->addICustomer(tempNP);
						nodePointers[z.nId]->addTreeToCustomerTree(tempNP);
						nodePointers[z.nId]->addTreeToProviderChain(tempNP);

						//update routing information
						establishLinkWithProvider(nodeId,z.nId);
						establishFlowWithProvider(nodeId,z.nId);

						//populate customers set (customers of z)
						list<NodePrice>::iterator it1;
						for(unsigned int i=0;i<activeNodes;i++){
							if(nodePointers[z.nId]->isPresentInCustomerTree(i))
								customers.push_back(i);
							else
								outsiders.push_back(i);
						}
						customers.push_front(z.nId);

						//terminate flows among customers if they are not peers, customer-providers, present in customer trees of each other's peers
						endConditionalFlowsBetweenSets(customers,customers);

						//terminate flows between customers and outsiders
						endConditionalFlowsBetweenSets(customers,outsiders);

						//re-establish flows
						//establish flows between x and the outside world
						establishFlowsBetweenNodeAndSet(z.nId,outsiders);

						//establish flows between customers
						establishFlowsBetweenSets(customers,customers);

						//establish flows between customers and the outside world
						establishFlowsBetweenSets(customers,outsiders);

						providerChange=true;

					}//end else Z is not Tier 1

				}// end if z is present in customer tree

				else{	//z is not present in customer tree

					//**put x in the customer tree of z
					NodePrice tempNP;
					tempNP.nId=nodeId;
					tempNP.price=z.price;

					//end previous flow of x with z
					endFlow(nodeId,z.nId);

					//update topology
					addQProvider(z);
					nodePointers[z.nId]->addICustomer(tempNP);
					nodePointers[z.nId]->addTreeToCustomerTree(tempNP);
					nodePointers[z.nId]->addTreeToProviderChain(tempNP);

					//update routing information
					establishLinkWithProvider(nodeId,z.nId);
					establishFlowWithProvider(nodeId,z.nId);

					//populate customers set (customers of z)
					list<NodePrice>::iterator it1;
					for(unsigned int i=0;i<activeNodes;i++){
						if(nodePointers[z.nId]->isPresentInCustomerTree(i))
							customers.push_back(i);
						else
							outsiders.push_back(i);
					}
					customers.push_front(z.nId);

					//terminate flows among customers if they are not peers, customer-providers, present in customer trees of each other's peers
					endConditionalFlowsBetweenSets(customers,customers);

					//terminate flows between customers and outsiders
					endConditionalFlowsBetweenSets(customers,outsiders);

					//re-establish flows
					//establish flows between x and the outside world
					establishFlowsBetweenNodeAndSet(z.nId,outsiders);

					//establish flows between customers
					establishFlowsBetweenSets(customers,customers);

					//establish flows between customers and the outside world
					establishFlowsBetweenSets(customers,outsiders);

					providerChange=true;

				}//end else z is not present in customer tree

			}//end else x is not Tier 1

		}while(!possibleProvider.empty());

	}//end else !possibleProvider.empty()

	return providerChange;

}//end getNewProvider

void Node::getProviderAsZ(unsigned int x, list<NodePrice>& zProvider){

	for(std::multimap<unsigned int,NodePrice>::iterator it=colocatedNodePrice.begin();it!=colocatedNodePrice.end();it++){
		if((*it).second.nId!=x && !nodePointers[x]->isPresentInCustomerTree((*it).second.nId) && !isPeer((*it).second.nId) && -1==isPresentInCustomerTreeOfPeer((*it).second.nId) && nodePointers[(*it).second.nId]->numGPresence>=numGPresence && nodePointers[(*it).second.nId]->Vt>Vt){
			zProvider.push_back((*it).second);
		}
	}

}

bool Node::getSettlementFreePeer(const int& id, bool isPaidPeeringLink){

	list<NodePrice> possiblePeers;
	list<NodePrice>::iterator itInt;
	map<unsigned int,bool> checked;
	NodePrice temp;
	list<unsigned int> setX;
	list<unsigned int> setY;
	int y;
	NodePrice peerInfo;
	NodePrice ownInfo;

	if(id==-1){	//generic peer finding

#if DEBUG
		cout<<"Node "<<nodeId<<" finding generic peers"<<endl;
#endif

		for(std::multimap<unsigned int,NodePrice>::iterator it=colocatedNodePrice.begin();it!=colocatedNodePrice.end();it++){
			checked[(*it).second.nId]=false;
		}

		for(std::multimap<unsigned int,NodePrice>::iterator it=colocatedNodePrice.begin();it!=colocatedNodePrice.end();it++){
			if(!isProvider((*it).second.nId) && !isPresentInCustomerTree((*it).second.nId) && !aliveNodes[(*it).second.nId].isPresentInCustomerTree(nodeId) && !isPeer((*it).second.nId) && checked.find((*it).second.nId)->second==false){

				checked[(*it).second.nId]=true;

				if(applyPeeringCriteria((*it).second.nId)==PEER && aliveNodes[(*it).second.nId].applyPeeringCriteria(nodeId)==PEER){
						possiblePeers.push_back((*it).second);

#if DEBUG
		cout<<"Node "<<nodeId<<" chose "<<(*it).second.nId<<" as possible peer"<<endl;
#endif
				}
			}
		}

	}

	else{
		temp.nId=id;
		temp.price=0;
		possiblePeers.push_back(temp);

	}

	if(possiblePeers.empty())
		return false;

#if EXPERIMENT

		vector<double> estimate;
		vector<double> actual;
		vector<double> estimateTo;
		vector<double> estimateFrom;

		for(unsigned int x=0;x<Node::activeNodes;x++){
			estimate.push_back(-1);
			estimateTo.push_back(-1);
			estimateFrom.push_back(-1);
			actual.push_back(-1);
		}

		if(!I.empty()){
			for(list<NodePrice>::iterator it=possiblePeers.begin();it!=possiblePeers.end();it++){
				estimate[(*it).nId]=estimateTrafficExchange((*it).nId);
				/*cout<<"Estimating To"<<endl;
				estimateTo[(*it).nId]=estimateTrafficTo((*it).nId);
				cout<<"Completed Estimation"<<endl;
				estimateFrom[(*it).nId]=estimateTrafficFrom((*it).nId);

				if(estimate[(*it).nId]!=(estimateTo[(*it).nId]+estimateFrom[(*it).nId])){
					cout<<"Estimates don't match for traffic between "<<nodeId<<" and "<<(*it).nId<<endl;
					cout<<"Estimate: "<<estimate[(*it).nId]<<" EstimateTo: "<<estimateTo[(*it).nId]<<" EstimateFrom: "<<estimateFrom[(*it).nId]<<endl;

				}
				*/
			}

		}
#endif

	for(std::list<NodePrice>::iterator it=possiblePeers.begin();it!=possiblePeers.end();it++){

#if DEBUG
		if(!I.empty())
			cout<<"Node "<<nodeId<<" peering with "<<(*it).nId<<endl;
#endif

		y=(*it).nId;
		setX.clear();
		setY.clear();

		peerInfo.nId=y;
		peerInfo.price=0;
		ownInfo.nId=nodeId;
		ownInfo.price=0;

		insertPeerInK(peerInfo);
		nodePointers[peerInfo.nId]->insertPeerInK(ownInfo);

		endFlow(nodeId,peerInfo.nId);
		establishLinkWithPeer(nodeId,peerInfo.nId,isPaidPeeringLink);
		establishFlowWithPeer(nodeId,peerInfo.nId);

		for(itInt=J.begin();itInt!=J.end();itInt++)
			if(!aliveNodes[y].isPresentInCustomerTree((*itInt).nId))
				setX.push_back((*itInt).nId);
		setX.push_front(nodeId);

		for(itInt=nodePointers[y]->J.begin();itInt!=nodePointers[y]->J.end();itInt++)
			if(!aliveNodes[nodeId].isPresentInCustomerTree((*itInt).nId))
				setY.push_back((*itInt).nId);
		setY.push_front(y);

		endConditionalFlowsBetweenSets(setX,setY);
		establishFlowsBetweenSets(setX,setY);

	}

#if DEBUG
		cout<<"Node "<<nodeId<<" found generic peers"<<endl;
#endif

#if EXPERIMENT
		if(!I.empty()){
			computeTrafficFlowsAcrossNetwork();
			for(list<NodePrice>::iterator it=possiblePeers.begin();it!=possiblePeers.end();it++){
				actual[(*it).nId]=linkValueVector[linkIndex[nodeId][(*it).nId].index];
			}
		

		char trafficDifferenceFileName[100];
		ofstream trafficDifferenceFile;
		sprintf(trafficDifferenceFileName,"trafficDifference_%d_%d_%d.txt",static_cast<int>(populationSeed),static_cast<int>(initialTopologySeed),static_cast<int>(playOrderSeed));
		trafficDifferenceFile.open(trafficDifferenceFileName,ios::app);

		char trafficDifferenceFileNameProvider[100];
		ofstream trafficDifferenceFileProvider;
		sprintf(trafficDifferenceFileNameProvider,"trafficDifferenceProvider_%d_%d_%d.txt",static_cast<int>(populationSeed),static_cast<int>(initialTopologySeed),static_cast<int>(playOrderSeed));
		trafficDifferenceFileProvider.open(trafficDifferenceFileNameProvider,ios::app);

		double diff;

		for(unsigned int x=0;x<Node::activeNodes;x++){
			if(isPeer(x) && estimate[x]!=-1 && actual[x]!=-1 && estimate[x]!=0 && actual[x]!=0){
				diff=((estimate[x]-actual[x])/estimate[x]);
				if(!std::isnan(diff)){
					trafficDifferenceFile<<nodeId<<"\t"<<x<<"\t"<<diff<<endl;

					if(!aliveNodes[x].I.empty())
						trafficDifferenceFileProvider<<nodeId<<"\t"<<x<<"\t"<<diff<<endl;
				}
			}
		}

		trafficDifferenceFile.close();
		trafficDifferenceFileProvider.close();
	}
#endif


	return true;

}

bool Node::dePeer(const int& id){

	/*
	 * Node doing de-peering is called: x
	 * Node being de-peered is called: y
	 *
	 */

	list<unsigned int>::iterator it;
	list<unsigned int> toDePeer;
	unsigned int y;
	list<unsigned int> setX;
	list<unsigned int> setY;
	list<unsigned int> setRest;
	bool dePeered=false;
	NodePrice temp;
	NodePrice peerInfo;
	NodePrice ownInfo;


	if(K.empty())
		return false;

	if(id==-1){	//dePeer generically
		for(std::list<NodePrice>::iterator itNP=K.begin();itNP!=K.end();itNP++){
			if(evaluateExistingPeer((*itNP).nId)==DONTPEER)
				toDePeer.push_back((*itNP).nId);
		}
	}

	else{	//dePeer specific node

		temp.nId=id;
		temp.price=0;
		toDePeer.push_back(temp.nId);

#if DEBUG
			cout<<"Node "<<nodeId<<" depeering "<<temp.nId<<endl;
#endif
	}

	if(toDePeer.empty())	//no node to depeer
		return false;


	for(it=toDePeer.begin();it!=toDePeer.end();it++){

		if(!isPeer(*it))	//forced depeering might have taken place
			continue;

		y=*it;
		setX.clear();
		setY.clear();
		setRest.clear();

		if(isTier1() && nodePointers[*it]->isTier1()){	//if both x and y are tier1

			if(!isCoLocated(*it))		//if they don't share geography then peering by necessity
				continue;

			else if(nodePointers[*it]->checkProvidersAfterDePeering(nodeId) && checkProvidersAfterDePeering(*it)){	//are x and y going to choose each other as provider
				continue;
			}

			else{

				dePeered=true;

				//remove y from Tier1 as it will no longer be T1
				nodePointers[y]->removeFromT1Set();

				//remove from eachother's peering list
				peerInfo.nId=y;
				peerInfo.price=0;
				ownInfo.nId=nodeId;
				ownInfo.price=0;

				removePeerFromK(peerInfo);
				nodePointers[y]->removePeerFromK(ownInfo);

				//end link and flow between eachother
				endLink(nodeId,y);
				endFlow(nodeId,y);

				//get new provider for y
				if(!nodePointers[y]->getNewProvider()){

					string str="ERROR!! Depeered T1 provider could not find a provider";
					endSimulation(str);
					return false;

				}

			}//end else Tier-1 y being depeered

		}//end if both Tier-1

		else{

			dePeered=true;

			peerInfo.nId=y;
			peerInfo.price=0;
			ownInfo.nId=nodeId;
			ownInfo.price=0;

			//remove from eachother's peering list
			removePeerFromK(peerInfo);
			nodePointers[peerInfo.nId]->removePeerFromK(ownInfo);

			//end link and flow between eachother
			endLink(nodeId,peerInfo.nId);

			endFlow(nodeId,peerInfo.nId);

			for(std::list<NodePrice>::iterator itNP=J.begin();itNP!=J.end();itNP++){
				setX.push_back((*itNP).nId);
			}
			setX.push_front(nodeId);

			for(std::list<NodePrice>::iterator itNP=nodePointers[y]->J.begin();itNP!=nodePointers[y]->J.end();itNP++){
				if(!isPresentInCustomerTree((*itNP).nId))
					setY.push_back((*itNP).nId);
			}
			setY.push_front(peerInfo.nId);

			endConditionalFlowsBetweenSets(setX,setY);

			establishFlowsBetweenSets(setX,setY);

		}//end else x & y are not both Tier-1

	}//end peering for loop

	return dePeered;

}

bool Node::checkProvidersAfterDePeering(const int& x){


	list<NodePrice> possibleProvider;
	map<unsigned int,double> providerMap;
	map<unsigned int,double>::iterator itMap;
	NodePrice tempNP,pProvider;
	NodePrice peerInfo;
	tempNP.nId=x;

	peerInfo.nId=x;
	peerInfo.price=0;

	if(x!=-1)
		removePeerFromK(peerInfo);	//temporarily remove x from peering list to expand possible provider set

	for(std::multimap<unsigned int,NodePrice>::iterator it=colocatedNodePrice.begin();it!=colocatedNodePrice.end();it++){
		if(!isPeer((*it).second.nId) && -1==isPresentInCustomerTreeOfPeer((*it).second.nId) && nodePointers[(*it).second.nId]->numGPresence>=numGPresence && nodePointers[(*it).second.nId]->Vt>Vt && nodePointers[(*it).second.nId]->numGPresence>1){

			pProvider.nId=(*it).second.nId;

			if(providerMap.find((*it).second.nId)!=providerMap.end()){
				if(providerMap[(*it).second.nId]>(*it).second.price){
					providerMap[(*it).second.nId]=(*it).second.price;
				}
			}

			else{
				providerMap[(*it).second.nId]=(*it).second.price;
			}

			pProvider.price=providerMap[(*it).second.nId];

			possibleProvider.push_back(pProvider);
			if(static_cast<int>(pProvider.nId)==x)
				tempNP.price=pProvider.price;
		}
	}

	possibleProvider.sort(sortByPrice);

	if(possibleProvider.size()>multihomingDegree){
		possibleProvider.resize(multihomingDegree);	//truncate to only the cheapest possible providers
	}

	return isPresentInList<NodePrice>(possibleProvider,tempNP);

}

peeringDecision Node::applyPeeringCriteria(const unsigned int& id){

	return (this->*dStrategyPointer)(id);

}

peeringDecision Node::evaluateExistingPeer(const unsigned int& id){

	return (this->*dStrategyPointer)(id);

}

void Node::selectPeeringStrategy(PeeringStrategies selectedStrategy){

	peeringStrategy=selectedStrategy;

	switch(peeringStrategy){

	case Selective:
		strategyPointer=&Node::peeringStrategySelective;
		dStrategyPointer=&Node::dePeeringStrategySelective;
		break;

	case Open:
		strategyPointer=&Node::peeringStrategyOpen;
		dStrategyPointer=&Node::dePeeringStrategyOpen;
		break;

	case Restrictive:
		strategyPointer=&Node::peeringStrategyRestrictive;
		dStrategyPointer=&Node::dePeeringStrategyRestrictive;
		break;

	default:
		string str="Non-existing peering strategy selected";
		endSimulation(str);
		break;

	}
}

peeringDecision Node::peeringStrategySelective(const unsigned int& id){

	if((this->trafficReceived[id]/trafficSent[id])<=selectivePeerCriteria)
		return PEER;
	else
		return DONTPEER;
	/*
	if((V/nodePointers[id]->V)<=selectivePeerCriteria)
		return PEER;
	else
		return DONTPEER;
	*/
}

peeringDecision Node::dePeeringStrategySelective(const unsigned int& id){

	if((this->trafficReceived[id]/trafficSent[id])<=selectivePeerCriteria)
		return PEER;
	else
		return DONTPEER;
	/*
	if((V/nodePointers[id]->V)<=selectivePeerCriteria)
		return PEER;
	else
		return DONTPEER;
	*/
}


peeringDecision Node::peeringStrategyOpen(const unsigned int& id){

	return PEER;
}

peeringDecision Node::dePeeringStrategyOpen(const unsigned int& id){

	return PEER;

}

peeringDecision Node::peeringStrategyRestrictive(const unsigned int& id){

	return DONTPEER;

}

peeringDecision Node::dePeeringStrategyRestrictive(const unsigned int& id){

	return PEER;
}

peeringDecision Node::peeringStrategySelectiveReal(const unsigned int& id){
	/*
	if((received/sent)<=universalSigma)
		return PEER;
	else
		return DONTPEER;
		*/
	return DONTPEER;	//TODO: fix this function. its incomplete
}

peeringDecision Node::dePeeringStrategySelectiveReal(const unsigned int& id){

	if(linkIndex[nodeId][id].index==-1){
		string str="ERROR!!! Depeering evaluation for nodes that are not peers";
		endSimulation(str);
		return DONTPEER;
	}

	double sent, received;
	unsigned int linkId=linkIndex[nodeId][id].index;

	if(nodeId<id){
		sent=linkValueVectorFlatLeft[linkId];
		received=linkValueVectorFlatRight[linkId];
	}
	else{
		received=linkValueVectorFlatLeft[linkId];
		sent=linkValueVectorFlatRight[linkId];
	}

	if((received/sent)<=universalSigma)
		return PEER;
	else
		return DONTPEER;

}

bool Node::updatePeeringStrategyFitnessPrediction(){

	/*
	 * Steps: Save state of the network
	 * Go over each strategy one by one and note down the fitness of each strategy
	 * Choose strategy that gives the best fitness
	 * Restore state of the network
	 * Return true if peering strategy changed
	 */

	list<PeeringStrategies>::iterator it;
	PeeringStrategies currentStrategy;
	double bestFitness;
	PeeringStrategies bestStrategy;
	double* fitnessRecord=new double[availablePeeringStrategies.size()];
	bool dePeeringChange;
	bool peeringChange;
	bool providerChange;

	updateFitness();
	currentStrategy=peeringStrategy;

	saveNetworkState();

	for(it=availablePeeringStrategies.begin();it!=availablePeeringStrategies.end();it++){

		if(it!=availablePeeringStrategies.begin())
			restoreNetworkState();

		selectPeeringStrategy(*it);

		dePeeringChange=dePeer(-1);

		peeringChange=getSettlementFreePeer(-1,false);

		providerChange=getNewProvider();

		if(dePeeringChange || peeringChange || providerChange){

			computeTrafficFlowsAcrossNetwork();
			updateVt();
		}

		updateFitness();

		fitnessRecord[*it]=fitness;

	}

	restoreNetworkState();

	delete []fitnessRecord;

	bestStrategy=defaultStrategy;	//default strategy is to peer restrictively
	bestFitness=fitnessRecord[defaultStrategy];

	for(unsigned int i=0;i<availablePeeringStrategies.size();i++){

		if(fitnessRecord[i]>bestFitness){
			bestStrategy=static_cast<PeeringStrategies>(i);
			bestFitness=fitnessRecord[i];

		}

	}

	if(bestStrategy!=currentStrategy){
		selectPeeringStrategy(bestStrategy);
		return true;
	}

	else
		return false;

}


void Node::addToT1Set(){

	list<unsigned int>::iterator itT;
	NodePrice peerInfo;
	NodePrice ownInfo;
	for(itT=Tier1.begin();itT!=Tier1.end();itT++)
		if(!isPeer(*itT)){
			endFlow(nodeId,*itT);

			peerInfo.nId=*itT;
			peerInfo.price=0;

			ownInfo.nId=nodeId;
			ownInfo.price=0;

			insertPeerInK(peerInfo);
			nodePointers[*itT]->insertPeerInK(ownInfo);
			establishLinkWithPeer(nodeId,*itT,false);
			establishFlowWithPeer(nodeId,*itT);
		}

	Tier1.push_back(nodeId);

}

void Node::removeFromT1Set(){

	NodePrice ownInfo;
	ownInfo.nId=nodeId;
	ownInfo.price=0;

	NodePrice peerInfo;

	Tier1.remove(nodeId);
	list<unsigned int>::iterator itT;
	for(itT=Tier1.begin();itT!=Tier1.end();itT++)
		if(isPeer(*itT) && !isCoLocated(*itT)){

			peerInfo.nId=*itT;
			peerInfo.price=0;

			removePeerFromK(peerInfo);
			nodePointers[*itT]->removePeerFromK(ownInfo);
			endLink(nodeId,*itT);
			endFlow(nodeId,*itT);
		}
}
